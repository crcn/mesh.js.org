{
  function trim(text) {
    return text.replace(/(^\s+)|(\s+$)/g, "");
  }

  function trimEmptyText(children) {
    return children.filter(function(child) {
      return child[0] !== "text" || child[1] !== "";
    });
  }
}

start
  = Children

Children
  = _ children:Child* _ {
    return trimEmptyText(children);
  }

InlineChild
  = (InlineElement/InlineText)

InlineChildren
  = children:InlineChild* {
    return children;
  }

InlineElement
  = (Image/Link/Emphasis)

StartChild
  = (Comment/Script/Element/Header/HorizontalRule/BlockQuote)

Child
  = (StartChild/InlineElement/List/Paragraph)

WS
  = [ \n\t\r] { return ["text", ""] };

Emphasis
  = (Code/Strong/Italic)

Code
  = "`" chars:CodeCharacter+ "`" {
    return ["element", "code", [], [["text", chars.join("")]]];
  }

CodeCharacter
  = !("`") char:InlineCharacter {
    return text();
  }

Strong
  = "**" chars:StrongCharacter+ "**" {
    return ["element", "strong", [], [["text", chars.join("")]]];
  }

StrongCharacter
  = !("**") char:InlineCharacter {
    return text();
  }

Italic
  = "*" chars:ItalicCharacter+ "*" {
    return ["element", "em", [], [["text", chars.join("")]]];
  }

ItalicCharacter
  = !("*") char:InlineCharacter {
    return text();
  }

Comment
  = "<!--" _ text:CommentCharacter+ _ "-->" {
    return ["comment", trim(text.join(""))];
  }

Element
  = _ child:(ElementWithoutChildren/ElementWithChildren) _ {
    return child;
  }

ElementWithChildren
  = "<" startName:Name attributes:Attribute* ">" children:Children "</" endName:Name ">" {

    if (endName && startName != endName) {
      expected("</" + endName + ">");
    }

    return ["element", startName, attributes, children];
  }

ElementWithoutChildren
  = "<" startName:Name attributes:Attribute* "/>" {
    return ["element", startName, attributes, []];
  }

Script
  = "<Script" attributes:Attribute* ">" _ chars:ScriptCharacter* _ "</Script>" {
    return ["element", "Script", attributes, [["text", chars.join("")]]];
  }

ScriptCharacter
  = !("</Script>") char:SourceCharacter {
    return text();
  }

Attribute
  = _ key:Name "=" value:String _ {
    return ["attribute", key, value[1]];
  }

String
  = "\"" chars:DoubleQuoteCharacter+ "\"" {
    return ["text", chars.join("")];
  }

DoubleQuoteCharacter
  = !("\"") char:SourceCharacter {
    return char;
  }

CommentCharacter
  = !("-->") text:SourceCharacter {
    return text;
  }


Link
  = "[" label:[^\]]+ "](" href:[^)]+ ")" {
    return ["element","a", [["attribute", "href", trim(href.join(""))]], [["text", trim(label.join(""))]]];
  }


Image
  = "![" alt:[^\]]+ "](" src:[^)]+ ")" {
    return ["element","img", [["attribute", "alt", trim(alt.join(""))], ["attribute", "src", trim(src.join(""))]], []];
  }

HorizontalRule
  = Dash Dash Dash Dash* EOL {
    return ["element", "hr", [], []];
  }

BlockQuote
  = ">" children:MultiInlineChildren {
    return ["blockquote", children];
  }


MultiInlineChildren
  = _ child:InlineChild children:NextLineChild* {
    return [child].concat(children);
  }

NextLineChild
  = _nt _ child:InlineChild {
    return child;
  }

Header
  = _ hashes:("#")+ _ children:InlineChildren EOL {
    return ["element", "h" + hashes.length, [], children];
  }

List
  = listItems:ListItem+  {
    return ["element", "ul", [], listItems];
  }

ListItem
  = Dash _ children:MultiInlineChildren _ {
    return ["element", "li", [], children];
  }

Dash
  = ("-"/"*")

Text
  = value:TextCharacter+ {
    return ["text", value.join("")];
  }

InlineText
  = value:(!(_n)TextCharacter _nt*)+ {
    return ["text", text()];
  }

Paragraph
  = children:(InlineElement/Text)+ {
    return ["element", "p", [], children];
  }

TextCharacter
  = !(StartChild/InlineElement/"<") value:SourceCharacter {
    return value;
  }

SourceCharacter
  = .

InlineCharacter
  = [^\n\r]

Word
  = chars:[a-zA-Z]+ { return chars.join(""); }

Name
  = chars:[a-zA-Z0-9-]+ { return chars.join(""); }
_
  = [ \n\r\t]*

_s
  = [ ]*

_t
  = [\t]

_n
  = [\n\r]

_nt
  = _n _t

EOL
  = (_n/EOF)

EOF
  = !.
